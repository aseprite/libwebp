// Copyright 2011 Google Inc. All Rights Reserved.
//
// This code is licensed under the same terms as WebM:
//  Software License Agreement:  http://www.webmproject.org/license/software/
//  Additional IP Rights Grant:  http://www.webmproject.org/license/additional/
// -----------------------------------------------------------------------------
//
// Author: jyrki@google.com (Jyrki Alakuijala)

#ifndef WEBP_BACKWARD_REFERENCES_H_
#define WEBP_BACKWARD_REFERENCES_H_

#include <assert.h>
#include <stdint.h>

#include "backward_distance.h"

// Backward reference distance codes, for all 32-bit values.
static const int kDistanceCodes = 40;

// Compression constants
static const int kLengthCodes = 24;
static const int kCodeLengthCodes = 19;
static const int kRowHasherXSubsampling = 7;
static const int kPaletteCodeBitsMax = 11;
static const int kPixOrCopyCodesMax =
    256 + kLengthCodes + (1 << kPaletteCodeBitsMax);
static const int kMaxLength = 4096;

enum Mode {
  kLiteral,
  kPaletteIx,
  kCopy,
  kNone,
};

typedef struct {
  // mode as uint 8, and not as type Mode, to make the memory layout
  // of this class to be exactly 8 bytes.
  uint8_t mode;
  uint16_t len;
  uint32_t argb_or_offset;
} PixOrCopy;

static inline PixOrCopy PixOrCopy_CreateCopy(uint32_t offset_arg,
                                             uint16_t len_arg) {
  PixOrCopy retval;
  retval.mode = kCopy;
  retval.argb_or_offset = offset_arg;
  retval.len = len_arg;
  return retval;
}

static inline PixOrCopy PixOrCopy_CreatePaletteIx(int ix) {
  assert(ix >= 0);
  assert(ix < (1 << kPaletteCodeBitsMax));
  PixOrCopy retval;
  retval.mode = kPaletteIx;
  retval.argb_or_offset = ix;
  retval.len = 1;
  return retval;
}

static inline PixOrCopy PixOrCopy_CreateLiteral(uint32_t argb_arg) {
  PixOrCopy retval;
  retval.mode = kLiteral;
  retval.argb_or_offset = argb_arg;
  retval.len = 1;
  return retval;
}

static inline int PixOrCopy_IsLiteral(const PixOrCopy *p) {
  return p->mode == kLiteral;
}

static inline int PixOrCopy_IsPaletteIx(const PixOrCopy *p) {
  return p->mode == kPaletteIx;
}

static inline int PixOrCopy_IsCopy(const PixOrCopy *p) {
  return p->mode == kCopy;
}

static inline uint32_t PixOrCopy_Literal(const PixOrCopy *p, int component) {
  assert(p->mode == kLiteral);
  return (p->argb_or_offset >> (component * 8)) & 0xff;
}

static inline uint32_t PixOrCopy_Length(const PixOrCopy *p) {
  return p->len;
}

static inline uint32_t PixOrCopy_Argb(const PixOrCopy *p) {
  assert(p->mode == kLiteral);
  return p->argb_or_offset;
}

static inline uint32_t PixOrCopy_PaletteIx(const PixOrCopy *p) {
  assert(p->mode == kPaletteIx);
  assert(p->argb_or_offset >= 0);
  assert(p->argb_or_offset < (1 << kPaletteCodeBitsMax));
  return p->argb_or_offset;
}

static inline uint32_t PixOrCopy_Distance(const PixOrCopy *p) {
  assert(p->mode == kCopy);
  return p->argb_or_offset;
}

static inline void PixOrCopy_LengthCodeAndBits(
    const PixOrCopy *p, int *code, int *n_bits, int *bits) {
  assert(p->len >= 1 && p->len <= kMaxLength);
  // Unlike flate, distance and length are encoded the same way.
  BackwardLength::Encode(p->len, code, n_bits, bits);
}


// Ridiculously simple backward references for images where it is unlikely
// that there are large backward references (photos).
void BackwardReferencesRle(
    int xsize,
    int ysize,
    const uint32_t *argb,
    PixOrCopy *stream,
    int *stream_size);

// This is a simple fast function for obtaining backward references
// based on simple heuristics.
void BackwardReferencesHashChain(
    int xsize,
    int ysize,
    int use_palette,
    const uint32_t *argb,
    int palette_bits,
    PixOrCopy *stream,
    int *stream_size);

// This method looks for a shortest path through the backward reference
// network based on a cost model generated by a first round of compression.
void BackwardReferencesTraceBackwards(
    int xsize,
    int ysize,
    int recursive_cost_model,
    int use_palette,
    const uint32_t *argb,
    int palette_bits,
    PixOrCopy *stream,
    int *stream_size);


// Convert backward references that are of linear distance along
// the image scan lines to have a 2d locality indexing where
// smaller values are used for backward references that are close by.
void BackwardReferences2DLocality(int xsize,
                                  int ysize,
                                  int data_size,
                                  PixOrCopy *data);

// Internals of locality transform exposed for testing use.
int DistanceToPlaneCode(int xsize, int ysize, int distance);

// Returns true if the given backward references actually produce
// the image given in tuple (argb, xsize, ysize).
int VerifyBackwardReferences(const uint32_t* argb,
                             int xsize, int ysize,
                             int palette_bits,
                             const PixOrCopy *lit,
                             int lit_size);

// Produce an estimate for a good emerging palette size for the image.
int CalculateEstimateForPaletteSize(const uint32_t *argb, int xsize, int ysize);

#endif  // WEBP_BACKWARD_REFERENCES_H_
